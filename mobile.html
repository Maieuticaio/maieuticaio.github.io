<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Словарь • Шагающий многогранник</title>
  <style>
    :root{
      --accent:#0a84ff;
      --muted:#6b7280;
      --drawer-w:84vw;
      --drawer-max:420px;
      --handle:36px;
    }
    html, body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 12px;
      background: #fff;
      position: relative;
      margin:0;
      height:100lvh; /* фиксируем высоту под большую вьюпорт-высоту, чтобы клавиатура не сдвигала макет */
      overflow:hidden;
    }
    svg { display:block; }
    /* фиксируем визуализацию по центру экрана, чтобы не прыгала при появлении клавиатуры */
    svg.viz{ position:relative; left:50%; transform:translateX(-50%) scale(var(--viz-scale, .6)); transform-origin:center; width:100%; height:auto; margin:0; }
    .ink { fill: none; stroke: #000; stroke-width: 3; stroke-linecap: round; vector-effect: non-scaling-stroke; }

    /* ВЫЕЗЖАЮЩИЙ СЛОВАРЬ */
    .drawer{position:fixed;top:0;right:0;height:100%;width:min(var(--drawer-w),var(--drawer-max));
      transform:translateX(100%);transition:transform .28s ease;
      background:#fff;border-left:1px solid #e5e7eb;box-shadow:-10px 0 30px rgba(0,0,0,.08);z-index:10}
    .drawer.open{transform:translateX(0)}
    .drawer .handle{position:absolute;left:calc(-0.5 * var(--handle));top:40%;width:var(--handle);height:var(--handle);background:#000;border-radius:50%;display:flex;align-items:center;justify-content:center;touch-action:none}
    .drawer .handle::after{content:"";display:block;border:2px solid #fff;border-left:0;border-top:0;width:10px;height:10px;transform:rotate(135deg);transition:transform .2s ease}
    .drawer.open .handle::after{transform:rotate(-45deg)}
    .drawer .sheet{display:flex;flex-direction:column;height:100%}
    .drawer header{position:relative;padding:14px 16px 10px;font-weight:700;display:flex;align-items:center;justify-content:flex-start}
    .addBtn{position:absolute;right:28px;top:50%;transform:translateY(-50%);width:36px;height:36px;border:none;background:transparent;border-radius:10px;display:grid;place-items:center;cursor:pointer;box-shadow:none;outline:none}
    .addBtn svg{width:16px;height:16px;transition:transform .2s ease}
    .addBtn.open svg{transform:rotate(45deg)}
    .list{padding:0 16px 24px;overflow:auto;flex:1;display:flex;flex-direction:column;gap:10px;width:100%;-webkit-overflow-scrolling:touch;overscroll-behavior:contain}
    .item{position:relative;display:flex;align-items:stretch;gap:0;padding:0;border:1px solid #eee;border-radius:12px;background:#fff;overflow:hidden;width:100%;flex:0 0 auto;min-height:56px}
    .item .content{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:12px;flex:1;transition:transform .18s ease;min-width:0}
    .item .content .left{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis}
    .item .del{position:absolute;right:0;top:0;bottom:0;width:56px;background:#fff;color:#000;display:grid;place-items:center;cursor:pointer;border:none;box-shadow:none}
    .item .del svg{width:18px;height:18px;display:block}
    .item strong{font-weight:700; word-break:break-word; }
    .item.swiped .content{transform:translateX(-72px)}
    .item strong{font-weight:700}
    .stats{color:var(--muted);font-size:12px;margin-left:6px}
    .play{width:36px;height:36px;border-radius:10px;border:1px solid #e5e7eb;background:transparent;display:grid;place-items:center}
    .play:hover{background:#f8f9fb}
    .play svg{width:18px;height:18px;display:block}

    /* ИНЛАЙН-ВВОД СПИСКОМ */
    .addrow{display:none;gap:8px;padding:8px 16px 0;margin-bottom:12px}
    .addrow textarea{width:100%;max-width:100%;min-height:48px;padding:12px;border:1px solid #e5e7eb;border-radius:12px;font-size:16px;line-height:1.4;background:#fff;box-shadow:none;outline:none;box-sizing:border-box;display:block;resize:none}
    .addrow textarea::placeholder{color:#6b7280;opacity:1}
    .addrow textarea:focus{outline:none;box-shadow:none;border-color:#e5e7eb}
    .addrow textarea::placeholder{color:#6b7280;opacity:1}
    .addrow textarea:focus{outline:none;box-shadow:none;border-color:#e5e7eb}
    .addrow button{padding:10px 12px;border-radius:10px;border:1px solid #e5e7eb;background:#f8f9fb;cursor:pointer}
    .addrow button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* КВИЗ*/
    .word{ text-align:center; font-weight:700; font-size:20px; margin:4px 0 10px; position:relative; display:flex; align-items:center; justify-content:center; gap:15px; }
    .word .label{display:inline-block;}
    .word::after{ display:none !important; }
    @keyframes caretBlink{ 0%,49%{ opacity:1 } 50%,100%{ opacity:0 } }
    .inputrow{ display:flex; gap:8px; margin-top:10px; }
    .inputrow input{ flex:1; padding:12px; border:none; border-radius:0; font-size:16px; background:#fff; outline:none; box-shadow:none; text-align:center; caret-color:#2563eb; }
    .inputrow input.showAnswer{ color: var(--muted); }
    .muted{ color:var(--muted); font-size:14px; }

    /* Позиционирование анимации и квиза */
    #block{ position:fixed; top: var(--block-top, 100px); left:50%; transform:translateX(-50%); width:min(92vw,520px); z-index:5; }
    svg.viz{ position:relative; left:50%; transform:translateX(-50%) scale(var(--viz-scale, .8)); transform-origin:center; width:100%; height:auto; }
    .quiz{ position:relative; width:100%; margin-top:0; }
    .word .speakQuiz{ position:relative; top:2px; width:28px; height:28px; border:none; background:transparent; display:grid; place-items:center; cursor:pointer; outline:none; }
    .word .speakQuiz svg{ width:18px; height:18px; display:block; }

    /* мелкий отклик при добавлении */
    #list.flash-add{ outline: 2px solid rgba(10,132,255,.25); outline-offset: 2px; transition: outline-color .3s; }
      /* Прятать фальш-курсор, когда вводим ответ */
    .quiz.typing .word::after, .quiz:focus-within .word::after{ display:none; }
  </style>
</head>
<body>
  <div id="block">
  <!-- Верхняя визуализация: линия и шаговая фигура -->
  <svg class="viz" viewBox="0 0 400 200" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Линия 400 пикселей, нарисованная от руки">
    <defs>
      <filter id="squiggleX" filterUnits="userSpaceOnUse" x="-80" y="-120" width="560" height="680">
        <feTurbulence type="fractalNoise" baseFrequency="0.02" numOctaves="1" seed="3" result="noise">
          <animate attributeName="baseFrequency" dur="1.6s" values="0.02;0.028;0.02" repeatCount="indefinite" />
        </feTurbulence>
        <feColorMatrix in="noise" type="matrix" result="noiseX"
          values="1 0 0 0 0
                  0 0 0 0 0
                  0 0 1 0 0
                  0 0 0 1 0" />
        <feDisplacementMap in="SourceGraphic" in2="noiseX" xChannelSelector="R" yChannelSelector="G" scale="1.6" />
      </filter>
    </defs>
    <g id="lineWrap">
      <!-- Линия-основание (невидимая, для геометрии) -->
      <line class="ink" x1="0" y1="160" x2="400" y2="160" style="stroke: transparent;" />
    </g>
    <g id="boxWrap" filter="url(#squiggleX)">
      <g id="shape">
        <polygon id="poly" class="ink" style="fill:#fff" points="" />
      </g>
    </g>
  </svg>

  <div class="quiz">
    <div id="quizWord" class="word">
      <span class="label"></span>
      <button id="speakQuiz" class="speakQuiz" title="Прослушать слово" aria-label="Прослушать слово">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M4 10h3l4-3v10l-4-3H4z"/>
          <path d="M16 9c1.5 1.5 1.5 4.5 0 6"/>
          <path d="M18 7c3 3 3 7 0 10"/>
        </svg>
      </button>
    </div>
    <div class="inputrow">
      <input id="quizInput" type="text" autocomplete="off" enterkeyhint="done" autocapitalize="none" autocorrect="off" spellcheck="false" />
    </div>
    <div id="quizFeedback" class="muted" style="margin-top:6px"></div>
  </div>
</div>

  <!-- Выезжающее окно слов справа -->
  <aside id="drawer" class="drawer" aria-label="Список слов">
    <div class="handle" id="handle" role="button" aria-label="Открыть словарь"></div>
    <div class="sheet">
      <header>Словарь <button id="addWordBtn" class="addBtn" title="Добавить"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg></button></header>
      <div class="addrow" id="addRow">
        <textarea id="addBulk" placeholder="Введи одно или несколько слов в формате \"слово - перевод\""></textarea>
        <button id="addSave" class="primary">Добавить</button>
      </div>
      <div id="list" class="list"></div>
    </div>
  </aside>

  <script>
  // === 1) АНИМАЦИЯ ФИГУРЫ, ШАГАЮЩЕЙ ПО ЛИНИИ ===
  (function(){
    const boxWrap = document.getElementById('boxWrap');
    const polyEl = document.getElementById('poly');

    const CX = 200;          // центр по X
    const lineY = 160;       // высота опорной линии
    const strokeShape = 3;   // толщина контура фигуры
    const strokeLine  = 3;   // толщина линии-основания

    // Время фигуры как у квадрата (константно для любой n)
    const BASE_ROTATE = 650;
    const BASE_PAUSE  = 200;
    const BASE_PER_STEP = BASE_ROTATE + BASE_PAUSE; // 850
    const BASE_STEPS   = 4;
    const TOTAL_PER_SHAPE = BASE_PER_STEP * BASE_STEPS; // 3400 мс

    // Радиус до вершин, под квадрат 100x100 (полудиагональ)
    const Rv = 70.710678;    // ≈ 50 * sqrt(2)

    let sides = 4;           // старт: квадрат
    const maxSides = 30;     // до тридцатиугольника, затем снова квадрат
    let angle = 0;           // текущий угол (в градусах)
    let pts = [];            // точки (центр в (0,0))
    window.__pendingDelta = window.__pendingDelta || 0;  // глобальный счетчик запросов морфа  // запрос изменения числа граней: -1 или +1

    function buildPointsN(n){
      const start = -Math.PI/2; // вершина сверху
      const arr = [];
      for(let i=0;i<n;i++){
        const a = start + i * (2*Math.PI/n);
        arr.push([Rv*Math.cos(a), Rv*Math.sin(a)]);
      }
      return arr;
    }

    function updatePolygon(){
      const pointsAttr = pts.map(([x,y]) => `${x.toFixed(3)},${y.toFixed(3)}`).join(' ');
      polyEl.setAttribute('points', pointsAttr);
    }

    function maxYAtAngle(angleDeg){
      const rad = angleDeg * Math.PI/180;
      const s = Math.sin(rad), c = Math.cos(rad);
      let maxY = -Infinity;
      for(const [x,y] of pts){
        const yp = x*s + y*c; // y' = x*sin + y*cos
        if(yp > maxY) maxY = yp;
      }
      return maxY;
    }

    function setTransform(angleDeg){
      const maxY = maxYAtAngle(angleDeg);
      const centerY = lineY - (strokeLine/2) - (maxY + strokeShape/2);
      boxWrap.setAttribute('transform', `translate(${CX}, ${centerY}) rotate(${angleDeg})`);
    }

    function easeInOutSine(t){ return 0.5 - 0.5*Math.cos(Math.PI*t); }

    function animateAngle(fromDeg, toDeg, duration){
      return new Promise(resolve => {
        const t0 = performance.now();
        function frame(t){
          if(document.hidden){ requestAnimationFrame(frame); return; }
          const p = Math.min(1, (t - t0)/duration);
          const ang = fromDeg + (toDeg - fromDeg)*easeInOutSine(p);
          setTransform(ang);
          if(p < 1) requestAnimationFrame(frame); else resolve();
        }
        requestAnimationFrame(frame);
      });
    }
// Морф n -> n+1: вставим точку посредине ребра 0-1, чтобы выровнять длины массивов
    function makeMorphPair(n){
      const A = buildPointsN(n);
      const B = buildPointsN(n+1);
      const mid01 = [(A[0][0]+A[1][0])/2, (A[0][1]+A[1][1])/2];
      const Aeq = [A[0], mid01, ...A.slice(1)]; // длина = n+1
      const Beq = B;
      return [Aeq, Beq];
    }
    // Универсальный equalizer для n -> m, где |m-n|=1
    function makeMorphPairAny(n, m){
      if(m === n+1){ return makeMorphPair(n); }
      if(m === n-1){
        const A = buildPointsN(n);
        const B = buildPointsN(m);
        const mid01 = [(B[0][0]+B[1][0])/2, (B[0][1]+B[1][1])/2];
        const Beq = [B[0], mid01, ...B.slice(1)]; // длина = n
        const Aeq = A; // уже длиной n
        return [Aeq, Beq];
      }
      // fallback: без морфа
      return [buildPointsN(n), buildPointsN(n)];
    }

    function animateMorph(Aeq, Beq, duration){
      return new Promise(resolve => {
        const t0 = performance.now();
        function frame(t){
          if(document.hidden){ requestAnimationFrame(frame); return; }
          const p = Math.min(1, (t - t0)/duration);
          const e = easeInOutSine(p);
          pts = Aeq.map((pA, i) => {
            const pB = Beq[i];
            return [ pA[0] + (pB[0]-pA[0])*e, pA[1] + (pB[1]-pA[1])*e ];
          });
          updatePolygon();
          setTransform(angle);
          if(p < 1) requestAnimationFrame(frame); else resolve();
        }
        requestAnimationFrame(frame);
      });
    }
async function walk(){
      while(true){
        pts = buildPointsN(sides);
        updatePolygon();
        setTransform(angle);

        let step = 360 / sides;
        const perStep  = TOTAL_PER_SHAPE / sides;             // мс на перекат
        const rotateMs = perStep * (BASE_ROTATE / BASE_PER_STEP);
        const pauseMs  = perStep * (BASE_PAUSE  / BASE_PER_STEP);
        for(let i=0;i<sides;i++){
          const next = angle + step;
          await animateAngle(angle, next, rotateMs);
          angle = next;
          if (i < sides - 1) { await new Promise(r=>setTimeout(r, pauseMs)); }

          // Если запросили изменение числа граней — морфим один раз после шага
          if(window.__pendingDelta !== 0){
            const delta = (window.__pendingDelta>0?1:-1);
            const target = Math.max(3, Math.min(maxSides, sides + delta));
            if(target !== sides){
              const [Aeq, Beq] = makeMorphPairAny(sides, target);
              await animateMorph(Aeq, Beq, 700);
              pts = Beq;
              sides = target;
              // пересчёт шага/таймингов после изменения n
              step = 360 / sides;
            }
            window.__pendingDelta = 0;
          }
        }
      }
    }

    pts = buildPointsN(sides);
    updatePolygon();
    setTransform(angle);
    walk();
  })();
  </script>

  <script>
// === 2) МИНИ-КВИЗ (фаззи-проверка, показ правильного ответа, очередь повторов) — FIXED ===
(function(){
  const quizWord = document.getElementById('quizWord');
  const quizLabel = document.querySelector('#quizWord .label');
  const quizInput = document.getElementById('quizInput');
  const quizFeedback = document.getElementById('quizFeedback');
  if(!quizWord || !quizInput || !quizLabel) return;

  // Очередь повторов: вернуть ошибочные слова через 2–3 задания
  const __defer = {
    queue: [], // { idx, left }
    schedule(idx){ this.queue.push({ idx, left: 2 + Math.floor(Math.random()*2) }); },
    tick(){ this.queue.forEach(d=>{ if(d.left>0) d.left--; }); },
    popDue(){ const k=this.queue.findIndex(d=>d.left<=0); if(k>=0){ const it=this.queue[k]; this.queue.splice(k,1); return it.idx; } return null; }
  };

  function pickNextIndex(){
    const data = window.__vocabData || [];
    const now = Date.now();
    if(!data.length) return 0;
    const DAY = 24*60*60*1000;
    let bestIdx = 0;
    let bestScore = -Infinity;
    for(let i=0;i<data.length;i++){
      const w = data[i];
      const due = Number(w.due||0);
      const overdue = due <= now ? 1 : 0;
      const diff = (w.bad|0) - (w.ok|0);
      const timeScore = overdue ? Math.min(3, (now - due)/DAY) : -Math.min(3, (due - now)/DAY);
      const score = (overdue?1000:0) + diff*10 + timeScore;
      if(score > bestScore){ bestScore = score; bestIdx = i; }
    }
    return bestIdx;
  }

  function initWhenReady(){
    // локальный озвучиватель
    function speakTerm(text, lang='en-US'){ if(!('speechSynthesis' in window)) return; const u=new SpeechSynthesisUtterance(text); u.lang=lang; speechSynthesis.speak(u); }
    const speakBtn = document.getElementById('speakQuiz');
    if(speakBtn && !speakBtn.dataset.bound){
      speakBtn.dataset.bound = '1';
      speakBtn.addEventListener('click', ()=>{
        const t=(quizLabel.textContent||'').trim();
        if(!t) return;
        if('speechSynthesis' in window){ try{ speechSynthesis.cancel(); }catch(_){} }
        speakTerm(t);
      });
    }

    if(!window.__vocabData || !window.__vocabData.length){
      document.addEventListener('vocab-ready', initWhenReady, { once:true });
      return;
    }

    let idx = -1;
    let lastIdx = -1;

    function setCard(){
      __defer.tick();
      // выбрать следующее, избегая немедленного повторения предыдущего
      let next = pickNextIndex();
      if(window.__vocabData.length > 1 && next === lastIdx){
        let best = -Infinity, bestIdx = next;
        for(let i=0;i<window.__vocabData.length;i++){
          if(i === lastIdx) continue;
          const w = window.__vocabData[i];
          const s = (w.bad|0) - (w.ok|0);
          if(s > best){ best = s; bestIdx = i; }
        }
        next = bestIdx;
      }
      idx = next;
      lastIdx = idx;
      quizLabel.textContent = window.__vocabData[idx].term;
      quizInput.readOnly = false;
      quizInput.classList.remove('showAnswer');
      quizInput.value = '';
      quizFeedback.textContent = '';
    }

    // Хелперы без регэкспов: нормализация, Левенштейн, 80% и варианты через split
    function clean(s){
      s = String(s||'').toLowerCase();
      var chars = ['.',',','!','?','"','\'','`','(',')','[',']'];
      for(var i=0;i<chars.length;i++){ s = s.split(chars[i]).join(' '); }
      s = s.trim();
      while(s.indexOf('  ')>=0) s = s.split('  ').join(' ');
      return s;
    }
    function lev(a,b){
      var m=a.length,n=b.length; if(!m||!n) return Math.max(m,n);
      var dp=new Array(n+1); for(var j=0;j<=n;j++) dp[j]=j;
      for(var i=1;i<=m;i++){
        var prev=dp[0]; dp[0]=i;
        for(var j2=1;j2<=n;j2++){
          var tmp=dp[j2]; var cost = a.charAt(i-1)===b.charAt(j2-1)?0:1;
          dp[j2] = Math.min(dp[j2]+1, dp[j2-1]+1, prev+cost);
          prev=tmp;
        }
      }
      return dp[n];
    }
    function sim(a,b){ a=clean(a); b=clean(b); var L=Math.max(a.length,b.length)||1; return 1-(lev(a,b)/L); }
    function splitVariants(tr){
      var base=String(tr||'');
      var acc=[]; base.split(';').forEach(function(a){ a.split(',').forEach(function(b){ b.split('/').forEach(function(c){ c.split('|').forEach(function(d){ acc.push(d.trim().toLowerCase()); }); }); }); });
      if(!acc.length) acc=[base.trim().toLowerCase()];
      return acc.filter(Boolean);
    }
    function fuzzyOK(input,tr){
      var x=clean(input);
      var vars=splitVariants(tr);
      // 1) фраза целиком
      for(var i=0;i<vars.length;i++){ if(sim(x, vars[i])>=0.8) return true; }
      if(!vars.length && sim(x, tr)>=0.8) return true;
      // 2) хотя бы одно слово из перевода (и из ответа) ≥80%
      var inWords=x.split(' ').filter(Boolean);
      var MINLEN=2;
      var targets = (vars.length? vars : [clean(tr)]);
      for(var t=0;t<targets.length;t++){
        var vWords = targets[t].split(' ').filter(Boolean);
        for(var iw=0;iw<inWords.length;iw++){ var wIn=inWords[iw]; if(wIn.length<MINLEN) continue;
          for(var vw=0;vw<vWords.length;vw++){ var wTr=vWords[vw]; if(wTr.length<MINLEN) continue;
            if( sim(wIn, wTr) >= 0.8 ) return true;
          }
        }
      }
      return false;
    }

    function submit(){
      const w = window.__vocabData[idx];
      const got = (quizInput.value||'').trim(); if(!got) return;
      const correct = fuzzyOK(got, w.tr);
      const answerText = String(w.tr||'');
      const okDelay = 800, badDelay = 1200;
      const DAY = 24*60*60*1000;
      function scheduleSuccess(item){
        item.reps = (item.reps|0) + 1;
        if(item.reps === 1){ item.interval = 1; }
        else if(item.reps === 2){ item.interval = 3; }
        else { item.interval = Math.round(Math.max(1, (item.interval||1) * (item.ease||2.5))); }
        item.ease = Math.max(1.3, (item.ease||2.5));
        item.due = Date.now() + item.interval * DAY;
      }
      function scheduleFailure(item){
        item.reps = 0;
        item.interval = 0;
        item.ease = Math.max(1.3, (item.ease||2.5) - 0.2);
        item.due = Date.now() + 1*DAY;
      }

      if(correct){
        w.ok = (w.ok|0) + 1;
        scheduleSuccess(w);
        if(window.__saveVocab) window.__saveVocab();
        if(window.__renderVocab) window.__renderVocab();
        quizInput.readOnly = true;
        quizInput.classList.add('showAnswer');
        quizInput.value = answerText;
        if(window.__queueMorph) window.__queueMorph(+1);
        setTimeout(()=>{ setCard(); quizInput.focus(); }, okDelay);
      } else {
        w.bad = (w.bad|0) + 1;
        scheduleFailure(w);
        if(window.__saveVocab) window.__saveVocab();
        if(window.__renderVocab) window.__renderVocab();
        quizInput.readOnly = true;
        quizInput.classList.add('showAnswer');
        quizInput.value = answerText;
        if(window.__queueMorph) window.__queueMorph(-1);
        __defer.schedule(idx);
        setTimeout(()=>{ setCard(); quizInput.focus(); }, badDelay);
      }
    }

    quizInput.addEventListener('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); submit(); } });('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); submit(); } });
    const quizBox = document.querySelector('.quiz');
    quizInput.addEventListener('focus', ()=> quizBox.classList.add('typing'));
    quizInput.addEventListener('blur',  ()=> quizBox.classList.remove('typing'));

    setCard();
    setTimeout(()=>quizInput.focus(), 0);
  }

  initWhenReady();
})();
</script>

  <script>
  // === 3) СЛОВАРЬ + ОЗВУЧКА + ДРАГ-ШТОРКА ===
  (function(){
    const list = document.getElementById('list');
    const LS_KEY = 'vocabV2';
    const defaults = [
      { term:'serendipity', tr:'счастливое случайное открытие', ok:0, bad:0 },
      { term:'petrichor', tr:'запах земли после дождя', ok:0, bad:0 },
      { term:'liminal', tr:'пороговый, промежуточный', ok:0, bad:0 },
      { term:'gossamer', tr:'тончайшая паутинка; невесомая ткань', ok:0, bad:0 },
      { term:'sonder', tr:'осознание сложной внутренней жизни у каждого', ok:0, bad:0 }
    ];

    // данные
    window.__vocabData = (function(){
      try{ const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : defaults; }
      catch(_){ return defaults; }
    })();
    // нормализация полей статистики
    window.__vocabData = window.__vocabData.map(w=>({
      term: w.term,
      tr: w.tr||'',
      ok: (w.ok|0),
      bad: (w.bad|0),
      reps: (w.reps|0),
      interval: (w.interval|0),
      ease: (typeof w.ease==='number' ? w.ease : 2.5),
      due: (typeof w.due==='number' ? w.due : Date.now())
    }));

    function speak(text, lang='en-US'){
      if(!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(text); u.lang=lang; speechSynthesis.speak(u);
    }
    function score(w){ return (w.bad|0) - (w.ok|0); }

    function render(){
      list.innerHTML='';
      const sorted = [...window.__vocabData].sort((a,b)=> ((b.bad|0)-(b.ok|0)) - ((a.bad|0)-(a.ok|0)) || a.term.localeCompare(b.term));
      sorted.forEach(w=>{
        const row=document.createElement('div'); row.className='item';
        // content (шевелится при свайпе)
        const content=document.createElement('div'); content.className='content';
        const left=document.createElement('div'); left.className='left'; left.innerHTML = `<strong>${w.term}</strong> — ${w.tr||''}`;
        const play=document.createElement('button'); play.className='play'; play.title='Прослушать';
        play.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 10h3l4-3v10l-4-3H4z"/>
          <path d="M16 9c1.5 1.5 1.5 4.5 0 6"/>
          <path d="M18 7c3 3 3 7 0 10"/>
        </svg>`;
        play.onclick=()=>speak(w.term);
        content.appendChild(left); content.appendChild(play);
        row.appendChild(content);

        const del=document.createElement('button'); del.className='del'; del.title='Удалить слово';
        del.innerHTML=`<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
          <path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/>
        </svg>`;
        del.onclick=()=>{
          const k = window.__vocabData.findIndex(v=> v.term===w.term && v.tr===w.tr);
          if(k>=0){ window.__vocabData.splice(k,1); saveLS(); render(); }
        };
        row.appendChild(del);

        // свайп-логика
        let sx=null, cur=0, opened=false; const MAX=72;
        function setX(x){ content.style.transform=`translateX(${x}px)`; }
        function onStart(x){ sx=x; row.style.willChange='transform'; }
        function onMove(x){ if(sx==null) return; const dx=x-sx; cur = Math.max(-MAX, Math.min(0, dx)); setX(opened? (-MAX + dx) : cur); }
        function onEnd(){ if(sx==null) return; const final = opened ? cur - MAX : cur; opened = (final <= -MAX*0.5); row.classList.toggle('swiped', opened); setX(opened? -MAX : 0); sx=null; cur=0; row.style.willChange='auto'; }
        row.addEventListener('touchstart',e=>onStart(e.touches[0].clientX),{passive:true});
        row.addEventListener('touchmove', e=>{ onMove(e.touches[0].clientX); },{passive:true});
        row.addEventListener('touchend', ()=>onEnd());
        row.addEventListener('mousedown', e=>{ onStart(e.clientX); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp, {once:true}); });
        function onMouseMove(e){ onMove(e.clientX); }
        function onMouseUp(){ onEnd(); window.removeEventListener('mousemove', onMouseMove); }

        list.appendChild(row);
      });
    }

    // экспорт и начальный рендер
    window.__renderVocab = render;
    render();
    try{ document.dispatchEvent(new CustomEvent('vocab-ready')); }catch(_){}

    // ПЛЮС → инлайн-ввод списком
    const addWordBtn = document.getElementById('addWordBtn');
    const addRow = document.getElementById('addRow');
    const addBulk = document.getElementById('addBulk');
    const addSave = document.getElementById('addSave');

    // авто-высота textarea под содержимое
    function autosizeTextarea(){
      if(!addBulk) return;
      addBulk.style.height = 'auto';
      const cap = Math.floor(window.innerHeight * 0.5); // не выше половины экрана
      addBulk.style.height = Math.min(addBulk.scrollHeight, cap) + 'px';
    }

    function toggleAdd(open){
      addRow.style.display = open ? 'grid' : 'none';
      if(open){
        setTimeout(()=>{ addBulk.focus(); autosizeTextarea(); },0);
      }
    }
    function saveLS(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(window.__vocabData)); }catch(_){} }
    window.__saveVocab = saveLS;
    // Экспорт запроса изменения числа граней
    window.__pendingDelta = window.__pendingDelta || 0;
    window.__queueMorph = function(delta){
      const d = (delta>0?1:-1);
      const cur = (window.__pendingDelta||0) + d;
      window.__pendingDelta = Math.max(-1, Math.min(1, cur));
    }

    function parsePair(s){
      const t=(s||'').trim(); if(!t) return null;
      const bySep=t.split(/\s*[-—–:]\s*/); if(bySep.length>=2){ const term=bySep.shift(); const tr=bySep.join(' - '); return {term, tr}; }
      const byWs=t.split(/\s{2,}|\t/);   if(byWs.length>=2){ return {term:byWs[0], tr:byWs.slice(1).join(' ')} }
      return {term:t, tr:''};
    }

    function addList(){
      const raw=(addBulk.value||'').trim();
      if(!raw) return;
      const lines = raw.split(/[;\n]+/).map(s=>s.trim()).filter(Boolean); // ✅ фикс: корректная регэксп
      let added = 0;
      for(const line of lines){ const pair = parsePair(line); if(pair && pair.term){ (function(){
          const exists = window.__vocabData.findIndex(v=> v.term.trim().toLowerCase()===pair.term.trim().toLowerCase() && (v.tr||'').trim().toLowerCase()===(pair.tr||'').trim().toLowerCase());
          if(exists<0){ window.__vocabData.push({term:pair.term, tr:pair.tr||'', ok:0, bad:0, reps:0, interval:0, ease:2.5, due: Date.now()}); added++; }
        })(); added++; } }
      if(!added) return;
      saveLS();
      render();
      addBulk.value='';
      addBulk.focus();
      list.classList.add('flash-add'); setTimeout(()=>list.classList.remove('flash-add'), 300);
    }

    if(addWordBtn){ addWordBtn.addEventListener('click', ()=>{ const open = addRow.style.display!=='grid'; toggleAdd(open); addWordBtn.classList.toggle('open', open); }); }
    if(addSave){ addSave.addEventListener('click', addList); }
    if(addBulk){ addBulk.addEventListener('input', autosizeTextarea); window.addEventListener('resize', autosizeTextarea); }
    if(addBulk){ addBulk.addEventListener('keydown', e=>{ if((e.metaKey||e.ctrlKey) && e.key==='Enter'){ e.preventDefault(); addList(); } }); }

    // Шторка (клик и свайп от правого края)
    const drawer = document.getElementById('drawer');
    const handle = document.getElementById('handle');
    let open=false, startX=null, startTx=0;
    const HANDLE_W = 18; // пол-ручки: наружу торчит только полукруг (радиус 18px)
    function drawerW(){ return Math.min(window.innerWidth*0.84, 420); }
    function closedTx(){ return drawerW(); }
    function setTx(x){ drawer.style.transition='none'; drawer.style.transform=`translateX(${x}px)`; }
    function snap(){ drawer.style.transition='transform .28s ease'; drawer.classList.toggle('open', open); drawer.style.transform=open?'translateX(0)':`translateX(${closedTx()}px)`; }
    function onDown(x){ open=drawer.classList.contains('open'); startX=x; startTx=open?0:closedTx(); drawer.style.willChange='transform'; }
    function onMove(x){ if(startX==null) return; const dx=startX-x; let tx=startTx+dx; tx=Math.max(0, Math.min(closedTx(), tx)); setTx(tx); }
    function onUp(x){ if(startX==null) return; const dx=startX-x; const tx=startTx+dx; open = tx < closedTx()/2; startX=null; drawer.style.willChange='auto'; snap(); }
    handle.addEventListener('click',()=>{ open=!drawer.classList.contains('open'); snap(); });
    handle.addEventListener('touchstart',e=>onDown(e.touches[0].clientX),{passive:true});
    handle.addEventListener('touchmove',e=>onMove(e.touches[0].clientX),{passive:true});
    handle.addEventListener('touchend',e=>onUp(e.changedTouches[0].clientX));
    let edgeDown=false;
    window.addEventListener('touchstart',e=>{ const x=e.touches[0].clientX; if(window.innerWidth - x < 18 && !drawer.classList.contains('open')){ edgeDown=true; onDown(x); } },{passive:true});
    window.addEventListener('touchmove',e=>{ if(edgeDown) onMove(e.touches[0].clientX); },{passive:true});
    window.addEventListener('touchend',e=>{ if(edgeDown){ onUp(e.changedTouches[0].clientX); edgeDown=false; } });
    drawer.classList.remove('open'); drawer.style.transform=`translateX(${closedTx()}px)`; // fully hide drawer, only half-circle handle visible
    window.addEventListener('resize',()=>{ if(!drawer.classList.contains('open')) drawer.style.transform=`translateX(${closedTx()}px)`; });
  })();
  </script>

  <script>
  // === 4) Привязка блока (анимация + слово + поле) к верху видимого окна ===
  (function(){
    const root = document.documentElement;
    const GAP_TOP = 100;   // весь блок на 100px от верхней границы экрана
    const SCALE = 0.6;     // масштаб анимации внутри блока

    function place(){
      const vv = window.visualViewport;
      const off = vv ? vv.offsetTop : 0;
      const top = off + GAP_TOP;
      root.style.setProperty('--block-top', top + 'px');
      root.style.setProperty('--viz-scale', String(SCALE));
    }
    place();
    if(window.visualViewport){
      visualViewport.addEventListener('resize', ()=>requestAnimationFrame(place));
      visualViewport.addEventListener('scroll', ()=>requestAnimationFrame(place));
    }
    window.addEventListener('resize', ()=>requestAnimationFrame(place));
    window.addEventListener('orientationchange', ()=>setTimeout(place, 300));
  })();
</script>

  <script>
  // === 5) МИНИ-ТЕСТЫ (для устойчивости будущих правок) ===
  (function(){
    function assert(name, cond){ if(!cond){ console.error('❌ Test failed:', name); throw new Error('Test failed: '+name); } else { console.log('✅', name); } }
    // Тест разбиения списка
    const raw = "apple - яблоко\nbanana — банан; cat: кот\n  dog  собака\tfish – рыба\nsolo";
    const parts = raw.split(/[;\n]+/).map(s=>s.trim()).filter(Boolean);
    assert('split /[;\n]+/ count', parts.length === 5);
    // Тест парсинга форматов
    function parsePair(s){
      const t=(s||'').trim(); if(!t) return null;
      const bySep=t.split(/\s*[-—–:]\s*/); if(bySep.length>=2){ const term=bySep.shift(); const tr=bySep.join(' - '); return {term, tr}; }
      const byWs=t.split(/\s{2,}|\t/);   if(byWs.length>=2){ return {term:byWs[0], tr:byWs.slice(1).join(' ')} }
      return {term:t, tr:''};
    }
    const cases = [
      ['apple - яблоко','яблоко'],
      ['banana — банан','банан'],
      ['cat: кот','кот'],
      ['dog  собака','собака'],
      ['fish\tрыба','рыба'],
      ['solo','']
    ];
    cases.forEach(([src, tr], i)=>{ const p=parsePair(src); assert('parse '+i, p && p.term && p.tr===tr); });
    console.log('✅ All parsing tests passed');
  })();
  </script>

</body>
</html>
