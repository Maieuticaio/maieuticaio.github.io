<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Словарь • Шагающий многогранник</title>
  <style>
    :root{
      --accent:#0a84ff;
      --muted:#6b7280;
      --drawer-w:84vw;
      --drawer-max:420px;
      --handle:36px;
    }
    html, body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 12px;
      background: #fff;
      position: relative; /* для абсолютного позиционирования квиза */
      margin:0;
      height:100%;
    }
    svg { width: min(92vw, 520px); height: auto; display: block; }
    .ink { fill: none; stroke: #000; stroke-width: 3; stroke-linecap: round; vector-effect: non-scaling-stroke; }

    /* ВЫЕЗЖАЮЩИЙ СЛОВАРЬ */
    .drawer{position:fixed;top:0;right:0;height:100%;width:min(var(--drawer-w),var(--drawer-max));
      transform:translateX(100%);transition:transform .28s ease;
      background:#fff;border-left:1px solid #e5e7eb;box-shadow:-10px 0 30px rgba(0,0,0,.08);z-index:10}
    .drawer.open{transform:translateX(0)}
    .drawer .handle{position:absolute;left:calc(-0.5 * var(--handle));top:40%;width:var(--handle);height:var(--handle);background:#000;border-radius:50%;display:flex;align-items:center;justify-content:center;touch-action:none}
    .drawer .handle::after{content:"";display:block;border:2px solid #fff;border-left:0;border-top:0;width:10px;height:10px;transform:rotate(135deg);transition:transform .2s ease}
    .drawer.open .handle::after{transform:rotate(-45deg)}
    .drawer .sheet{display:flex;flex-direction:column;height:100%}
    .drawer header{position:relative;padding:14px 16px 10px;font-weight:700;display:flex;align-items:center;justify-content:flex-start}
    .addBtn{position:absolute;right:28px;top:50%;transform:translateY(-50%);width:36px;height:36px;border:none;background:transparent;border-radius:10px;display:grid;place-items:center;cursor:pointer;box-shadow:none;outline:none}
    .addBtn svg{width:16px;height:16px;transition:transform .2s ease}
    .addBtn.open svg{transform:rotate(45deg)}
    .list{padding:0 16px 24px;overflow:auto;flex:1;display:flex;flex-direction:column;gap:10px}
    .item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:12px;border:1px solid #eee;border-radius:12px;background:#fff}
    .item strong{font-weight:700}
    .stats{color:var(--muted);font-size:12px;margin-left:6px}
    .play{width:36px;height:36px;border-radius:10px;border:1px solid #e5e7eb;background:transparent;display:grid;place-items:center}
    .play:hover{background:#f8f9fb}
    .play svg{width:18px;height:18px;display:block}

    /* ИНЛАЙН-ВВОД СПИСКОМ */
    .addrow{display:none;gap:8px;padding:8px 16px 0;margin-bottom:12px}
    .addrow textarea{width:100%;max-width:100%;min-height:48px;padding:12px;border:1px solid #e5e7eb;border-radius:12px;font-size:16px;line-height:1.4;background:#fff;box-shadow:none;outline:none;box-sizing:border-box;display:block;resize:none}
    .addrow textarea::placeholder{color:#6b7280;opacity:1}
    .addrow textarea:focus{outline:none;box-shadow:none;border-color:#e5e7eb}
    .addrow textarea::placeholder{color:#6b7280;opacity:1}
    .addrow textarea:focus{outline:none;box-shadow:none;border-color:#e5e7eb}
    .addrow button{padding:10px 12px;border-radius:10px;border:1px solid #e5e7eb;background:#f8f9fb;cursor:pointer}
    .addrow button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* КВИЗ*/
    .word{ text-align:center; font-weight:700; font-size:20px; margin:4px 0 10px; position:relative; }
    .word::after{ display:none !important; }
    @keyframes caretBlink{ 0%,49%{ opacity:1 } 50%,100%{ opacity:0 } }
    .inputrow{ display:flex; gap:8px; }
    .inputrow input{ flex:1; padding:12px; border:none; border-radius:0; font-size:16px; background:#fff; outline:none; box-shadow:none; text-align:center; caret-color:#2563eb; }
    .inputrow input.showAnswer{ color: var(--muted); }
    .muted{ color:var(--muted); font-size:14px; }

    /* Позиционирование анимации и квиза */
    svg.viz{ transform: translateY(var(--viz-translateY, -100px)) scale(var(--viz-scale, .8)); transform-origin: top center; }
    .quiz{ position:absolute; top:50vh; left:50%; transform:translateX(-50%); width:min(92vw,520px); margin:0; }

    /* мелкий отклик при добавлении */
    #list.flash-add{ outline: 2px solid rgba(10,132,255,.25); outline-offset: 2px; transition: outline-color .3s; }
      /* Прятать фальш-курсор, когда вводим ответ */
    .quiz.typing .word::after, .quiz:focus-within .word::after{ display:none; }
  </style>
</head>
<body>
  <!-- Верхняя визуализация: линия и шаговая фигура -->
  <svg class="viz" viewBox="0 0 400 500" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Линия 400 пикселей, нарисованная от руки">
    <defs>
      <filter id="squiggleX" filterUnits="userSpaceOnUse" x="-80" y="-120" width="560" height="680">
        <feTurbulence type="fractalNoise" baseFrequency="0.02" numOctaves="1" seed="3" result="noise">
          <animate attributeName="baseFrequency" dur="1.6s" values="0.02;0.028;0.02" repeatCount="indefinite" />
        </feTurbulence>
        <feColorMatrix in="noise" type="matrix" result="noiseX"
          values="1 0 0 0 0
                  0 0 0 0 0
                  0 0 1 0 0
                  0 0 0 1 0" />
        <feDisplacementMap in="SourceGraphic" in2="noiseX" xChannelSelector="R" yChannelSelector="G" scale="1.6" />
      </filter>
    </defs>
    <g id="lineWrap">
      <!-- Линия-основание (невидимая, для геометрии) -->
      <line class="ink" x1="0" y1="300" x2="400" y2="300" style="stroke: transparent;" />
    </g>
    <g id="boxWrap" filter="url(#squiggleX)">
      <g id="shape">
        <polygon id="poly" class="ink" style="fill:#fff" points="" />
      </g>
    </g>
  </svg>

  <div class="quiz">
    <div id="quizWord" class="word"></div>
    <div class="inputrow">
      <input id="quizInput" type="text" autocomplete="off" enterkeyhint="done" autocapitalize="none" autocorrect="off" spellcheck="false" />
    </div>
    <div id="quizFeedback" class="muted" style="margin-top:6px"></div>
  </div>

  <!-- Выезжающее окно слов справа -->
  <aside id="drawer" class="drawer" aria-label="Список слов">
    <div class="handle" id="handle" role="button" aria-label="Открыть словарь"></div>
    <div class="sheet">
      <header>Словарь <button id="addWordBtn" class="addBtn" title="Добавить"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg></button></header>
      <div class="addrow" id="addRow">
        <textarea id="addBulk" placeholder="Введи одно или несколько слов в формате \"слово - перевод\""></textarea>
        <button id="addSave" class="primary">Добавить</button>
      </div>
      <div id="list" class="list"></div>
    </div>
  </aside>

  <script>
  // === 1) АНИМАЦИЯ ФИГУРЫ, ШАГАЮЩЕЙ ПО ЛИНИИ ===
  (function(){
    const boxWrap = document.getElementById('boxWrap');
    const polyEl = document.getElementById('poly');

    const CX = 200;          // центр по X
    const lineY = 300;       // высота опорной линии
    const strokeShape = 3;   // толщина контура фигуры
    const strokeLine  = 3;   // толщина линии-основания

    // Время фигуры как у квадрата (константно для любой n)
    const BASE_ROTATE = 650;
    const BASE_PAUSE  = 200;
    const BASE_PER_STEP = BASE_ROTATE + BASE_PAUSE; // 850
    const BASE_STEPS   = 4;
    const TOTAL_PER_SHAPE = BASE_PER_STEP * BASE_STEPS; // 3400 мс

    // Радиус до вершин, под квадрат 100x100 (полудиагональ)
    const Rv = 70.710678;    // ≈ 50 * sqrt(2)

    let sides = 4;           // старт: квадрат
    const maxSides = 30;     // до тридцатиугольника, затем снова квадрат
    let angle = 0;           // текущий угол (в градусах)
    let pts = [];            // точки (центр в (0,0))
    window.__pendingDelta = window.__pendingDelta || 0;  // глобальный счетчик запросов морфа  // запрос изменения числа граней: -1 или +1

    function buildPointsN(n){
      const start = -Math.PI/2; // вершина сверху
      const arr = [];
      for(let i=0;i<n;i++){
        const a = start + i * (2*Math.PI/n);
        arr.push([Rv*Math.cos(a), Rv*Math.sin(a)]);
      }
      return arr;
    }

    function updatePolygon(){
      const pointsAttr = pts.map(([x,y]) => `${x.toFixed(3)},${y.toFixed(3)}`).join(' ');
      polyEl.setAttribute('points', pointsAttr);
    }

    function maxYAtAngle(angleDeg){
      const rad = angleDeg * Math.PI/180;
      const s = Math.sin(rad), c = Math.cos(rad);
      let maxY = -Infinity;
      for(const [x,y] of pts){
        const yp = x*s + y*c; // y' = x*sin + y*cos
        if(yp > maxY) maxY = yp;
      }
      return maxY;
    }

    function setTransform(angleDeg){
      const maxY = maxYAtAngle(angleDeg);
      const centerY = lineY - (strokeLine/2) - (maxY + strokeShape/2);
      boxWrap.setAttribute('transform', `translate(${CX}, ${centerY}) rotate(${angleDeg})`);
    }

    function easeInOutSine(t){ return 0.5 - 0.5*Math.cos(Math.PI*t); }

    function animateAngle(fromDeg, toDeg, duration){
      return new Promise(resolve => {
        const t0 = performance.now();
        function frame(t){
          const p = Math.min(1, (t - t0)/duration);
          const ang = fromDeg + (toDeg - fromDeg)*easeInOutSine(p);
          setTransform(ang);
          if(p < 1) requestAnimationFrame(frame); else resolve();
        }
        requestAnimationFrame(frame);
      });
    }

    // Морф n -> n+1: вставим точку посредине ребра 0-1, чтобы выровнять длины массивов
    function makeMorphPair(n){
      const A = buildPointsN(n);
      const B = buildPointsN(n+1);
      const mid01 = [(A[0][0]+A[1][0])/2, (A[0][1]+A[1][1])/2];
      const Aeq = [A[0], mid01, ...A.slice(1)]; // длина = n+1
      const Beq = B;
      return [Aeq, Beq];
    }
    // Универсальный equalizer для n -> m, где |m-n|=1
    function makeMorphPairAny(n, m){
      if(m === n+1){ return makeMorphPair(n); }
      if(m === n-1){
        const A = buildPointsN(n);
        const B = buildPointsN(m);
        const mid01 = [(B[0][0]+B[1][0])/2, (B[0][1]+B[1][1])/2];
        const Beq = [B[0], mid01, ...B.slice(1)]; // длина = n
        const Aeq = A; // уже длиной n
        return [Aeq, Beq];
      }
      // fallback: без морфа
      return [buildPointsN(n), buildPointsN(n)];
    }

    function animateMorph(Aeq, Beq, duration){
      return new Promise(resolve => {
        const t0 = performance.now();
        function frame(t){
          const p = Math.min(1, (t - t0)/duration);
          const e = easeInOutSine(p);
          pts = Aeq.map((pA, i) => {
            const pB = Beq[i];
            return [ pA[0] + (pB[0]-pA[0])*e, pA[1] + (pB[1]-pA[1])*e ];
          });
          updatePolygon();
          setTransform(angle);
          if(p < 1) requestAnimationFrame(frame); else resolve();
        }
        requestAnimationFrame(frame);
      });
    }

    async function walk(){
      while(true){
        pts = buildPointsN(sides);
        updatePolygon();
        setTransform(angle);

        let step = 360 / sides;
        const perStep  = TOTAL_PER_SHAPE / sides;             // мс на перекат
        const rotateMs = perStep * (BASE_ROTATE / BASE_PER_STEP);
        const pauseMs  = perStep * (BASE_PAUSE  / BASE_PER_STEP);
        for(let i=0;i<sides;i++){
          const next = angle + step;
          await animateAngle(angle, next, rotateMs);
          angle = next;
          if (i < sides - 1) { await new Promise(r=>setTimeout(r, pauseMs)); }

          // Если запросили изменение числа граней — морфим один раз после шага
          if(window.__pendingDelta !== 0){
            const delta = (window.__pendingDelta>0?1:-1);
            const target = Math.max(3, Math.min(maxSides, sides + delta));
            if(target !== sides){
              const [Aeq, Beq] = makeMorphPairAny(sides, target);
              await animateMorph(Aeq, Beq, 700);
              pts = Beq;
              sides = target;
              // пересчёт шага/таймингов после изменения n
              step = 360 / sides;
            }
            window.__pendingDelta = 0;
          }
        }
      }
    }

    pts = buildPointsN(sides);
    updatePolygon();
    setTransform(angle);
    walk();
  })();
  </script>

  <script>
// === 2) МИНИ-КВИЗ (фаззи-проверка, показ правильного ответа, очередь повторов) ===
(function(){
  const quizWord = document.getElementById('quizWord');
  const quizInput = document.getElementById('quizInput');
  const quizFeedback = document.getElementById('quizFeedback');
  if(!quizWord || !quizInput) return;

  // Очередь повторов: вернуть ошибочные слова через 2–3 задания
  const __defer = {
    queue: [], // { idx, left }
    schedule(idx){ this.queue.push({ idx, left: 2 + Math.floor(Math.random()*2) }); },
    tick(){ this.queue.forEach(d=>{ if(d.left>0) d.left--; }); },
    popDue(){ const k=this.queue.findIndex(d=>d.left<=0); if(k>=0){ const it=this.queue[k]; this.queue.splice(k,1); return it.idx; } return null; }
  };

  function pickNextIndex(){
    const due = __defer.popDue(); if(due!=null) return due;
    let bestScore = -Infinity, bestIdx = 0;
    for(let i=0;i<window.__vocabData.length;i++){
      const w = window.__vocabData[i];
      const s = (w.bad|0) - (w.ok|0);
      if(s > bestScore){ bestScore = s; bestIdx = i; }
    }
    return bestIdx;
  }

  function initWhenReady(){
    if(!window.__vocabData || !window.__vocabData.length){ return setTimeout(initWhenReady, 50); }
    let idx = pickNextIndex();

    // не повторять то же слово сразу после ответа
    let lastIdx = -1;

    function setCard(){
      __defer.tick();
      // выбрать следующее, избегая немедленного повторения предыдущего
      let next = pickNextIndex();
      if(window.__vocabData.length > 1 && next === lastIdx){
        let best = -Infinity, bestIdx = next;
        for(let i=0;i<window.__vocabData.length;i++){
          if(i === lastIdx) continue;
          const w = window.__vocabData[i];
          const s = (w.bad|0) - (w.ok|0);
          if(s > best){ best = s; bestIdx = i; }
        }
        next = bestIdx;
      }
      idx = next;
      lastIdx = idx;
      quizWord.textContent = window.__vocabData[idx].term;
      quizInput.readOnly = false;
      quizInput.classList.remove('showAnswer');
      quizInput.value = '';
      quizFeedback.textContent = '';
    }

    // Хелперы без регэкспов: нормализация, Левенштейн, 80% и варианты через split
    function clean(s){
      s = String(s||'').toLowerCase();
      var chars = ['.',',','!','?','"','\'','`','(',')','[',']'];
      for(var i=0;i<chars.length;i++){ s = s.split(chars[i]).join(' '); }
      s = s.trim();
      while(s.indexOf('  ')>=0) s = s.split('  ').join(' ');
      return s;
    }
    function lev(a,b){
      var m=a.length,n=b.length; if(!m||!n) return Math.max(m,n);
      var dp=new Array(n+1); for(var j=0;j<=n;j++) dp[j]=j;
      for(var i=1;i<=m;i++){
        var prev=dp[0]; dp[0]=i;
        for(var j2=1;j2<=n;j2++){
          var tmp=dp[j2]; var cost = a.charAt(i-1)===b.charAt(j2-1)?0:1;
          dp[j2] = Math.min(dp[j2]+1, dp[j2-1]+1, prev+cost);
          prev=tmp;
        }
      }
      return dp[n];
    }
    function sim(a,b){ a=clean(a); b=clean(b); var L=Math.max(a.length,b.length)||1; return 1-(lev(a,b)/L); }
    function splitVariants(tr){
      var base=String(tr||'');
      var acc=[]; base.split(';').forEach(function(a){ a.split(',').forEach(function(b){ b.split('/').forEach(function(c){ c.split('|').forEach(function(d){ acc.push(d.trim().toLowerCase()); }); }); }); });
      if(!acc.length) acc=[base.trim().toLowerCase()];
      return acc.filter(Boolean);
    }
    function fuzzyOK(input,tr){
      var x=clean(input);
      var vars=splitVariants(tr);
      // 1) фраза целиком
      for(var i=0;i<vars.length;i++){ if(sim(x, vars[i])>=0.8) return true; }
      if(!vars.length && sim(x, tr)>=0.8) return true;
      // 2) хотя бы одно слово из перевода (и из ответа) ≥80%
      var inWords=x.split(' ').filter(Boolean);
      var MINLEN=3;
      var targets = (vars.length? vars : [clean(tr)]);
      for(var t=0;t<targets.length;t++){
        var vWords = targets[t].split(' ').filter(Boolean);
        for(var iw=0;iw<inWords.length;iw++){ var wIn=inWords[iw]; if(wIn.length<MINLEN) continue;
          for(var vw=0;vw<vWords.length;vw++){ var wTr=vWords[vw]; if(wTr.length<MINLEN) continue;
            if( sim(wIn, wTr) >= 0.8 ) return true;
          }
        }
      }
      return false;
    }

    function submit(){
      const w = window.__vocabData[idx];
      const got = (quizInput.value||'').trim(); if(!got) return;
      const correct = fuzzyOK(got, w.tr);
      const answerText = String(w.tr||'');
      const okDelay = 800, badDelay = 1200;
      if(correct){
        w.ok = (w.ok|0) + 1;
        if(window.__saveVocab) window.__saveVocab();
        if(window.__renderVocab) window.__renderVocab();
        // показать полный ответ прямо в поле
        quizInput.readOnly = true;
        quizInput.classList.add('showAnswer');
        quizInput.value = answerText;
        if(window.__queueMorph) window.__queueMorph(+1);
        setTimeout(()=>{ setCard(); quizInput.focus(); }, okDelay);
      } else {
        w.bad = (w.bad|0) + 1;
        if(window.__saveVocab) window.__saveVocab();
        if(window.__renderVocab) window.__renderVocab();
        // показать правильный ответ прямо в поле
        quizInput.readOnly = true;
        quizInput.classList.add('showAnswer');
        quizInput.value = answerText;
        if(window.__queueMorph) window.__queueMorph(-1);
        __defer.schedule(idx);
        setTimeout(()=>{ setCard(); quizInput.focus(); }, badDelay);
      }
    }

    quizInput.addEventListener('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); submit(); } });
    const quizBox = document.querySelector('.quiz');
    quizInput.addEventListener('focus', ()=> quizBox.classList.add('typing'));
    quizInput.addEventListener('blur',  ()=> quizBox.classList.remove('typing'));

    setCard();
    setTimeout(()=>quizInput.focus(), 0);
  }
  initWhenReady();
})();
</script>

  <script>
  // === 3) СЛОВАРЬ + ОЗВУЧКА + ДРАГ-ШТОРКА ===
  (function(){
    const list = document.getElementById('list');
    const LS_KEY = 'vocabV2';
    const defaults = [
      { term:'serendipity', tr:'счастливое случайное открытие', ok:0, bad:0 },
      { term:'petrichor', tr:'запах земли после дождя', ok:0, bad:0 },
      { term:'liminal', tr:'пороговый, промежуточный', ok:0, bad:0 },
      { term:'gossamer', tr:'тончайшая паутинка; невесомая ткань', ok:0, bad:0 },
      { term:'sonder', tr:'осознание сложной внутренней жизни у каждого', ok:0, bad:0 }
    ];

    // данные
    window.__vocabData = (function(){
      try{ const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : defaults; }
      catch(_){ return defaults; }
    })();
    // нормализация полей статистики
    window.__vocabData = window.__vocabData.map(w=>({ term:w.term, tr:w.tr||'', ok: (w.ok|0), bad: (w.bad|0) }));

    function speak(text, lang='en-US'){
      if(!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(text); u.lang=lang; speechSynthesis.speak(u);
    }
    function score(w){ return (w.bad|0) - (w.ok|0); }

    function render(){
      list.innerHTML='';
      const sorted = [...window.__vocabData].sort((a,b)=> ((b.bad|0)-(b.ok|0)) - ((a.bad|0)-(a.ok|0)) || a.term.localeCompare(b.term));
      sorted.forEach(w=>{
        const row=document.createElement('div'); row.className='item';
        const left=document.createElement('div'); left.innerHTML=`<strong>${w.term}</strong> — ${w.tr||''}`;
        const play=document.createElement('button'); play.className='play'; play.title='Прослушать';
        play.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 10h3l4-3v10l-4-3H4z"/>
          <path d="M16 9c1.5 1.5 1.5 4.5 0 6"/>
          <path d="M18 7c3 3 3 7 0 10"/>
        </svg>`;
        play.onclick=()=>speak(w.term);
        row.appendChild(left); row.appendChild(play); list.appendChild(row);
      });
    }
    // экспорт и начальный рендер
    window.__renderVocab = render;
    render();

    // ПЛЮС → инлайн-ввод списком
    const addWordBtn = document.getElementById('addWordBtn');
    const addRow = document.getElementById('addRow');
    const addBulk = document.getElementById('addBulk');
    const addSave = document.getElementById('addSave');

    // авто-высота textarea под содержимое
    function autosizeTextarea(){
      if(!addBulk) return;
      addBulk.style.height = 'auto';
      const cap = Math.floor(window.innerHeight * 0.5); // не выше половины экрана
      addBulk.style.height = Math.min(addBulk.scrollHeight, cap) + 'px';
    }

    function toggleAdd(open){
      addRow.style.display = open ? 'grid' : 'none';
      if(open){
        setTimeout(()=>{ addBulk.focus(); autosizeTextarea(); },0);
      }
    }
    function saveLS(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(window.__vocabData)); }catch(_){} }
    window.__saveVocab = saveLS;
    // Экспорт запроса изменения числа граней
    window.__pendingDelta = window.__pendingDelta || 0;
    window.__queueMorph = function(delta){
      const d = (delta>0?1:-1);
      const cur = (window.__pendingDelta||0) + d;
      window.__pendingDelta = Math.max(-1, Math.min(1, cur));
    }

    function parsePair(s){
      const t=(s||'').trim(); if(!t) return null;
      const bySep=t.split(/\s*[-—–:]\s*/); if(bySep.length>=2){ const term=bySep.shift(); const tr=bySep.join(' - '); return {term, tr}; }
      const byWs=t.split(/\s{2,}|\t/);   if(byWs.length>=2){ return {term:byWs[0], tr:byWs.slice(1).join(' ')} }
      return {term:t, tr:''};
    }

    function addList(){
      const raw=(addBulk.value||'').trim();
      if(!raw) return;
      const lines = raw.split(/[;\n]+/).map(s=>s.trim()).filter(Boolean); // ✅ фикс: корректная регэксп
      let added = 0;
      for(const line of lines){ const pair = parsePair(line); if(pair && pair.term){ window.__vocabData.push({term:pair.term, tr:pair.tr||'', ok:0, bad:0}); added++; } }
      if(!added) return;
      saveLS();
      render();
      addBulk.value='';
      addBulk.focus();
      list.classList.add('flash-add'); setTimeout(()=>list.classList.remove('flash-add'), 300);
    }

    if(addWordBtn){ addWordBtn.addEventListener('click', ()=>{ const open = addRow.style.display!=='grid'; toggleAdd(open); addWordBtn.classList.toggle('open', open); }); }
    if(addSave){ addSave.addEventListener('click', addList); }
    if(addBulk){ addBulk.addEventListener('input', autosizeTextarea); window.addEventListener('resize', autosizeTextarea); }
    if(addBulk){ addBulk.addEventListener('keydown', e=>{ if((e.metaKey||e.ctrlKey) && e.key==='Enter'){ e.preventDefault(); addList(); } }); }

    // Шторка (клик и свайп от правого края)
    const drawer = document.getElementById('drawer');
    const handle = document.getElementById('handle');
    let open=false, startX=null, startTx=0;
    const HANDLE_W = 18; // пол-ручки: наружу торчит только полукруг (радиус 18px)
    function drawerW(){ return Math.min(window.innerWidth*0.84, 420); }
    function closedTx(){ return drawerW(); }
    function setTx(x){ drawer.style.transition='none'; drawer.style.transform=`translateX(${x}px)`; }
    function snap(){ drawer.style.transition='transform .28s ease'; drawer.classList.toggle('open', open); drawer.style.transform=open?'translateX(0)':`translateX(${closedTx()}px)`; }
    function onDown(x){ open=drawer.classList.contains('open'); startX=x; startTx=open?0:closedTx(); drawer.style.willChange='transform'; }
    function onMove(x){ if(startX==null) return; const dx=startX-x; let tx=startTx+dx; tx=Math.max(0, Math.min(closedTx(), tx)); setTx(tx); }
    function onUp(x){ if(startX==null) return; const dx=startX-x; const tx=startTx+dx; open = tx < closedTx()/2; startX=null; drawer.style.willChange='auto'; snap(); }
    handle.addEventListener('click',()=>{ open=!drawer.classList.contains('open'); snap(); });
    handle.addEventListener('touchstart',e=>onDown(e.touches[0].clientX),{passive:true});
    handle.addEventListener('touchmove',e=>onMove(e.touches[0].clientX),{passive:true});
    handle.addEventListener('touchend',e=>onUp(e.changedTouches[0].clientX));
    let edgeDown=false;
    window.addEventListener('touchstart',e=>{ const x=e.touches[0].clientX; if(window.innerWidth - x < 18 && !drawer.classList.contains('open')){ edgeDown=true; onDown(x); } },{passive:true});
    window.addEventListener('touchmove',e=>{ if(edgeDown) onMove(e.touches[0].clientX); },{passive:true});
    window.addEventListener('touchend',e=>{ if(edgeDown){ onUp(e.changedTouches[0].clientX); edgeDown=false; } });
    drawer.classList.remove('open'); drawer.style.transform=`translateX(${closedTx()}px)`; // fully hide drawer, only half-circle handle visible
    window.addEventListener('resize',()=>{ if(!drawer.classList.contains('open')) drawer.style.transform=`translateX(${closedTx()}px)`; });
  })();
  </script>

  <script>
  // === 4) АДАПТАЦИЯ ПОД МОБИЛЬНУЮ КЛАВИАТУРУ ===
  (function(){
    const root = document.documentElement;
    const quiz = document.querySelector('.quiz');
    const input = document.getElementById('quizInput');

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    const BASE_SCALE = 0.8;   // фиксированный масштаб анимации
    const BASE_TY    = -100;  // фиксированный сдвиг анимации вверх

    function applyLayout(){
      const vv = window.visualViewport;
      const vh = vv ? vv.height : window.innerHeight;
      const fullH = window.innerHeight;
      const pageTop = vv ? vv.pageTop : window.scrollY || 0;

      const typing = document.activeElement === input;

      // Центруем блок квиза относительно видимой области, но НЕ дергаем при наборе текста
      if(!typing){
        const quizTop = Math.round(pageTop + vh * 0.5);
        quiz.style.top = quizTop + 'px';
      }

      // Во время открытой клавиатуры не трогаем анимацию — оставляем на месте
      const keyboardOpen = vv ? (fullH - vh) > 120 : typing;
      if(keyboardOpen){
        root.style.setProperty('--viz-scale', BASE_SCALE.toFixed(3));
        root.style.setProperty('--viz-translateY', BASE_TY + 'px');
        return;
      }


      // Когда клавиатуры нет — можно подстраивать масштаб под высоту окна (как раньше)
      const targetScale = (vh * 0.45) / 500;
      const s = clamp(Math.min(BASE_SCALE, targetScale), 0.5, BASE_SCALE);
      root.style.setProperty('--viz-scale', s.toFixed(3));
      const ty = (s < 0.7) ? -70 : BASE_TY;
      root.style.setProperty('--viz-translateY', ty + 'px');
    }

    if(window.visualViewport){
      visualViewport.addEventListener('resize', applyLayout);
      visualViewport.addEventListener('scroll', applyLayout);
    }
    window.addEventListener('resize', applyLayout);
    window.addEventListener('scroll', applyLayout, {passive:true});
    input.addEventListener('focus', applyLayout);
    input.addEventListener('blur', applyLayout);
    applyLayout();
  })();
  </script>

  <script>
  // === 5) МИНИ-ТЕСТЫ (для устойчивости будущих правок) ===
  (function(){
    function assert(name, cond){ if(!cond){ console.error('❌ Test failed:', name); throw new Error('Test failed: '+name); } else { console.log('✅', name); } }
    // Тест разбиения списка
    const raw = "apple - яблоко\nbanana — банан; cat: кот\n  dog  собака\tfish – рыба\nsolo";
    const parts = raw.split(/[;\n]+/).map(s=>s.trim()).filter(Boolean);
    assert('split /[;\n]+/ count', parts.length === 5);
    // Тест парсинга форматов
    function parsePair(s){
      const t=(s||'').trim(); if(!t) return null;
      const bySep=t.split(/\s*[-—–:]\s*/); if(bySep.length>=2){ const term=bySep.shift(); const tr=bySep.join(' - '); return {term, tr}; }
      const byWs=t.split(/\s{2,}|\t/);   if(byWs.length>=2){ return {term:byWs[0], tr:byWs.slice(1).join(' ')} }
      return {term:t, tr:''};
    }
    const cases = [
      ['apple - яблоко','яблоко'],
      ['banana — банан','банан'],
      ['cat: кот','кот'],
      ['dog  собака','собака'],
      ['fish\tрыба','рыба'],
      ['solo','']
    ];
    cases.forEach(([src, tr], i)=>{ const p=parsePair(src); assert('parse '+i, p && p.term && p.tr===tr); });
    console.log('✅ All parsing tests passed');
  })();
  </script>

</body>
</html>
