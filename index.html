<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game / Vocabulary — v1.3</title>
  <style>
    :root { --nav-top:50px; --nav-left:50px; --gap:10px; --ph-h:44px; }
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }

    /* ===== Nav ===== */
    .nav { position: absolute; top: var(--nav-top); left: var(--nav-left); display: flex; gap: var(--gap); align-items: center; z-index: 1000; }
    .ph { width: 140px; height: 44px; display: grid; place-items: center; border-radius: 8px; border: 1px solid rgba(0,0,0,.15); background: #fff; cursor: pointer; user-select: none; font-weight: 600; letter-spacing: .2px; }
    .ph.active { background: repeating-conic-gradient(#e5e5e5 0 8deg, #f7f7f7 8deg 16deg); }

    .page { padding: 140px 24px 24px 50px; }
    .hidden { display: none; }

    /* ===== Vocabulary ===== */
    .vocab { position: absolute; top: calc(var(--nav-top) + 120px); left: 60px; right: 60px; }
    .vrow { display: grid; grid-template-columns: 375px 100px 375px 50px auto; align-items: center; height: 70px; }
    .vrow + .vrow { border-top: 1px solid rgba(0,0,0,.08); }
    /* highlight for freshly imported rows */
    .vrow.new { background: #fffbe6; }
    @keyframes flashNew { 0% { background:#fff3c4; } 100% { background:#fffbe6; } }
    .vrow.new { animation: flashNew 1s ease-out 1; }
    .cell.word { font-weight: 600; }
    .cell.trans { color: rgba(0,0,0,.75); }
    .cell.okcount { width: 50px; justify-self: end; text-align: right; font: 12px/1 ui-monospace, Menlo, Consolas, monospace; opacity: .9; }
    .icon-btn { width: 30px; height: 30px; display: grid; place-items: center; background: transparent; border: none; padding: 0; cursor: pointer; line-height: 0; }
    .icon-btn.speak { justify-self: center; }
    .icon-btn.delete { font-size: 18px; grid-column: 5; justify-self: end; }

    #page-vocab { position: relative; }
    .fab-round { position: fixed; top: calc(var(--nav-top) + (var(--ph-h) / 2) - 28px); width: 56px; height: 56px; border-radius: 50%; background: #fff; border: 1px solid rgba(0,0,0,.15); display: grid; place-items: center; cursor: pointer; transition: transform .08s ease; z-index: 1200; }
    .fab-add { right: 50px; }
    .fab-list { right: calc(50px + 56px + 10px); }
    .fab-round:active { transform: scale(1.1); }

    /* ===== Game ===== */
    .game-stage { position: fixed; inset: 0; display: grid; place-items: center; }
    .runner { width: 60px; height: 60px; animation: bob 1.6s ease-in-out infinite alternate; }
    .runner svg { display: block; }
    .runner-shape { transform-origin: 50% 50%; }
    @keyframes rotateNeg90 { from { transform: rotate(0deg); } to { transform: rotate(-90deg); } }
    .runner-shape.spinNeg90 { animation: rotateNeg90 400ms linear 1; }
    @keyframes bob { from { transform: translateY(-5px); } to { transform: translateY(5px); } }

    /* Knockback on wrong answer (overlays bob) */
    @keyframes knockback {
      0%   { transform: translateX(0); }
      35%  { transform: translateX(-50px); }
      100% { transform: translateX(0); }
    }
    .runner.knock { animation: bob 1.6s ease-in-out infinite alternate, knockback 520ms cubic-bezier(0.22,0.61,0.36,1) 1; }

    .obstacle-anchor { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .obstacle { width: 12px; height: 240px; animation: approach-loop 3s linear infinite; will-change: transform; }
    /* first obstacle invisible until first iteration completes */
    .obstacle.transparent { opacity: 0 !important; }
    .obstacle svg { display: block; width: 100%; height: 100%; }
    @keyframes approach-loop { 0% { transform: translateX(55vw); } 100% { transform: translateX(-55vw); } }

    /* Pause flags */
    .paused .runner, .paused .obstacle { animation-play-state: paused !important; }

    /* Overlay */
    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.35); z-index: 2000; }
    .overlay.show { display: flex; }
    .overlay, .dialog { pointer-events: auto; }
    .dialog { width: 600px; height: 400px; background: #fff; border: 1px solid rgba(0,0,0,.15); border-radius: 12px; display: grid; grid-template-rows: 1fr auto 1fr; padding: 24px; box-shadow: 0 12px 40px rgba(0,0,0,.2); }
    .dialog .word { align-self: end; text-align: center; font-size: 40px; font-weight: 700; letter-spacing: .5px; }
    .input-ce { align-self: start; justify-self: center; font: 18px/1.6 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: transparent; border: none; outline: none; padding: 0; margin-top: 20px; min-height: 32px; white-space: pre-wrap; text-align: center; display: inline-block; }
    @keyframes caretBlink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    .input-ce::after { content: "_"; display: inline-block; animation: caretBlink 1s steps(2, end) infinite; }
    .input-ce.showing-correct::after { content: ""; }

    /* Score + Theme invert */
    .score { position: fixed; right: 50px; bottom: 50px; z-index: 1500; font: 700 18px/1 ui-monospace, Menlo, Consolas, monospace; letter-spacing: .5px; }
    .score span { display: inline-block; min-width: 24px; text-align: center; }
    body { background: #ffffff; }
    body.inverted {
      background-color: #000000;
      background-image:
        radial-gradient(2px 2px at 12% 18%, rgba(255,255,255,.6) 1.6px, transparent 2px),
        radial-gradient(2px 2px at 42% 62%, rgba(255,255,255,.6) 1.6px, transparent 2px),
        radial-gradient(2.4px 2.4px at 78% 24%, rgba(255,255,255,.6) 1.8px, transparent 2.4px),
        radial-gradient(1.6px 1.6px at 65% 83%, rgba(255,255,255,.6) 1.2px, transparent 1.6px),
        radial-gradient(2px 2px at 28% 76%, rgba(255,255,255,.6) 1.6px, transparent 2px);
      background-size: 200px 200px, 260px 260px, 320px 320px, 180px 180px, 240px 240px;
      background-repeat: repeat;
      background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
      animation: stars-scroll 6s linear infinite;
    }
    @keyframes stars-scroll {
      from { background-position: 0 0, 0 0, 0 0, 0 0, 0 0; }
      to   { background-position: -200px 0, -260px 0, -320px 0, -180px 0, -240px 0; }
    }
    body.inverted.paused { background-image: none !important; animation: none !important; }
    .app { filter: none; min-height: 100vh; width: 100%; }
    body.inverted .app { filter: invert(1); }

    /* ===== Import Dialog (list) ===== */
    .dialog-import { width: 600px; height: 400px; background: #fff; border: 1px solid rgba(0,0,0,.15); border-radius: 12px; box-shadow: 0 12px 40px rgba(0,0,0,.2); position: relative; display: flex; flex-direction: column; padding: 16px; }
    .dialog-import .dia-icon { position: absolute; top: 10px; width: 28px; height: 28px; border-radius: 50%; background: #fff; border: 1px solid rgba(0,0,0,.15); display: grid; place-items: center; cursor: pointer; }
    .dialog-import .dia-ok { right: 46px; }
    .dialog-import .dia-close { right: 10px; }
    .dialog-import .import-text { flex: 1; margin-top: 8px; resize: none; width: 100%; border: none; outline: none; font: 16px/1.5 ui-monospace, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <div class="app">
    <div id="nav" class="nav" aria-label="Навигация по страницам">
      <div id="btn-game" class="ph active" role="button" tabindex="0" aria-pressed="true">Game</div>
      <div id="btn-vocab" class="ph" role="button" tabindex="0" aria-pressed="false">Vocabulary</div>
    </div>

    <main>
      <section id="page-game" class="page">
        <div class="game-stage">
          <div class="runner" aria-label="running square">
            <svg class="runner-shape" width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <defs>
                <filter id="wobble-stroke" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">
                  <feTurbulence type="fractalNoise" baseFrequency=".25" numOctaves="1" seed="3" result="noise"/>
                  <feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G"/>
                </filter>
              </defs>
              <rect x="1" y="1" width="58" height="58" fill="#fff"/>
              <rect x="1" y="1" width="58" height="58" fill="none" stroke="#000" stroke-width="2" filter="url(#wobble-stroke)"/>
            </svg>
          </div>
          <div class="obstacle-anchor" aria-hidden="true">
            <div class="obstacle transparent">
              <svg viewBox="0 0 12 240" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <defs>
                  <filter id="wobble-stroke-obs" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">
                    <feTurbulence type="fractalNoise" baseFrequency=".25" numOctaves="1" seed="5" result="noise"/>
                    <feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G"/>
                  </filter>
                </defs>
                <rect x="1" y="1" width="10" height="238" fill="#fff"/>
                <rect x="1" y="1" width="10" height="238" fill="none" stroke="#000" stroke-width="2" filter="url(#wobble-stroke-obs)"/>
              </svg>
            </div>
          </div>

          <div class="overlay" id="quizOverlay" aria-hidden="true">
            <div class="dialog" role="dialog" aria-modal="true">
              <div class="word" id="quizWord">word</div>
              <div id="quizInputCE" class="input-ce" contenteditable="true" role="textbox" aria-label="Введите перевод и нажмите Enter" spellcheck="false" tabindex="0"></div>
              <div></div>
            </div>
          </div>
          <div class="score" id="score"><span id="ok">0</span>&nbsp;&nbsp;<span id="fail">0</span></div>
        </div>
      </section>

      <section id="page-vocab" class="page hidden">
        <div class="vocab" id="vocab"></div>
        <button id="fabList" class="fab-round fab-list" aria-label="Показать список">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <circle cx="12" cy="12" r="10.5" fill="white" stroke="rgba(0,0,0,.15)"/>
            <path d="M8 8h8M8 12h8M8 16h8" stroke="#000" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
        <button id="fabAdd" class="fab-round fab-add" aria-label="Добавить слово">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <circle cx="12" cy="12" r="10.5" fill="white" stroke="rgba(0,0,0,.15)"/>
            <path d="M12 7v10M7 12h10" stroke="#000" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
      </section>

      <!-- Import Text Dialog -->
      <div class="overlay" id="listOverlay" aria-hidden="true">
        <div class="dialog-import" role="dialog" aria-modal="true" aria-label="Импорт слов">
          <button id="listOk" class="dia-icon dia-ok" title="Готово" aria-label="Готово">✓</button>
          <button id="listClose" class="dia-icon dia-close" title="Закрыть" aria-label="Закрыть">✕</button>
          <textarea id="listText" class="import-text" placeholder="Вставьте список слов. Один в строке.
Формат: word (pos) — перевод"></textarea>
        </div>
      </div>
    </main>
  </div>

  <script>
  (function(){
    /* ====== Small helpers ====== */
    const $ = (s, r=document) => r.querySelector(s);
    const focusEnd = (el) => { el && el.focus && el.focus(); const r=document.createRange(); r.selectNodeContents(el); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); };

    // === Fuzzy matching helpers (RU/EN letters, small typos allowed) ===
    const normalizeText = (s) => (s||'').toLowerCase().replace(/ё/g,'е');
    const splitWords = (s) => normalizeText(s).match(/[a-zа-я]+/g) || [];
    const levenshtein = (a,b)=>{
      const m=a.length, n=b.length; if(!m) return n; if(!n) return m;
      const dp=new Array(n+1); for(let j=0;j<=n;j++) dp[j]=j;
      for(let i=1;i<=m;i++){
        let prev=dp[0]++, cur;
        for(let j=1;j<=n;j++){
          cur = Math.min(
            dp[j] + 1,
            dp[j-1] + 1,
            prev + (a[i-1]===b[j-1]?0:1)
          );
          prev = dp[j]; dp[j] = cur;
        }
      }
      return dp[n];
    };
    const isFuzzyCorrect = (input, translation)=>{
      const ins = splitWords(input);
      if (ins.length===0) return false;
      const trs = Array.from(new Set(splitWords(translation)));
      for (const iv of ins){
        for (const tv of trs){
          const thr = tv.length <= 4 ? 1 : 2; // allow small typos
          if (Math.abs(iv.length - tv.length) > thr) continue; // cheap reject
          const d = levenshtein(iv, tv);
          if (iv===tv || d<=thr) return true;
        }
      }
      return false;
    };
    const normCmp = (s)=> normalizeText(s).replace(/[^a-zа-я0-9]+/g,' ').trim();

    /* ===== Speech (Web Speech API) ===== */
    const synth = window.speechSynthesis;
    let cachedVoices = [];
    function refreshVoices(){ try { cachedVoices = synth.getVoices(); } catch(_) { cachedVoices = []; } }
    refreshVoices();
    if (typeof synth !== 'undefined' && 'onvoiceschanged' in synth) { synth.onvoiceschanged = refreshVoices; }
    function detectLang(s){ return /[а-яё]/i.test(s) ? 'ru-RU' : 'en-US'; }
    function speakWord(text){
      try{
        if (!text) return;
        const utt = new SpeechSynthesisUtterance(text);
        const lang = detectLang(text);
        utt.lang = lang;
        utt.rate = 0.95;
        utt.pitch = 1.0;
        const exact = cachedVoices.find(v=>v.lang === lang);
        const prefix = cachedVoices.find(v=> (v.lang||'').startsWith(lang.split('-')[0]));
        utt.voice = exact || prefix || cachedVoices[0] || null;
        synth.cancel();
        synth.speak(utt);
      } catch(err){ console.error('TTS error', err); }
    }

    /* ====== Nav ====== */
    const btnGame=$('#btn-game'), btnVocab=$('#btn-vocab');
    const pageGame=$('#page-game'), pageVocab=$('#page-vocab');
    function setPage(page){
      const isGame = page==='game';
      btnGame.classList.toggle('active', isGame); btnVocab.classList.toggle('active', !isGame);
      btnGame.setAttribute('aria-pressed', isGame?'true':'false'); btnVocab.setAttribute('aria-pressed', isGame?'false':'true');
      pageGame.classList.toggle('hidden', !isGame); pageVocab.classList.toggle('hidden', isGame);
      if (isGame) document.body.classList.remove('paused');
    }
    btnGame.addEventListener('click', ()=>setPage('game'));
    btnVocab.addEventListener('click', ()=>setPage('vocab'));
    const keyHandler = (p)=> (e)=>{ if (e.key==='Enter'||e.key===' ') { e.preventDefault(); setPage(p); } };
    btnGame.addEventListener('keydown', keyHandler('game')); btnVocab.addEventListener('keydown', keyHandler('vocab'));

    /* ====== Data ====== */
    const SPEAKER_SVG = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 9h4l5-4v14l-5-4H4z" stroke="black" fill="none"/><path d="M16 8a5 5 0 0 1 0 8" stroke="black" fill="none"/><path d="M18 6a8 8 0 0 1 0 12" stroke="black" fill="none"/></svg>';

    const INITIAL_WORDS = [ ['maieutica (n)','майевтика'] ];
    const WORDS = INITIAL_WORDS.slice();
    let LAST_IMPORTED = []; // words recently added via import dialog
    let RETRY_QUEUE = []; // short-term queue for mistaken words: {w,t,delay}
    const VOCAB_KEY = 'vocabList';
    function saveVocab(){ try { localStorage.setItem(VOCAB_KEY, JSON.stringify(WORDS)); } catch(_){} }
    function loadVocab(){
      try{
        const raw = localStorage.getItem(VOCAB_KEY);
        const arr = JSON.parse(raw || '[]');
        if (Array.isArray(arr) && arr.length>0 && arr.every(r=>Array.isArray(r) && r.length>=2)){
          WORDS.length = 0;
          arr.forEach(([w,t])=> WORDS.push([String(w), String(t)]));
          return true;
        }
      }catch(_){}
      WORDS.length = 0;
      INITIAL_WORDS.forEach(([w,t])=> WORDS.push([w,t]));
      saveVocab();
      return false;
    }

    /* ====== okStore ====== */
    const OK_KEY='vocabOk';
    const okStore = (()=>{
      const key = (w)=> (w||'').trim().toLowerCase();
      const load = ()=>{ try { return JSON.parse(localStorage.getItem(OK_KEY)||'{}'); } catch(_) { return {}; } };
      const save = (o)=>{ localStorage.setItem(OK_KEY, JSON.stringify(o)); };
      return {
        key,
        _ : load,
        save,
        get(w){ const o=load(); return o[key(w)]|0; },
        inc(w,by=1){ const o=load(); const k=key(w); o[k]=(o[k]|0)+by; save(o); },
        del(w){ const o=load(); delete o[key(w)]; save(o); }
      };
    })();
    function purgeOrphanOk(){
      try{
        const keep = new Set(WORDS.map(([w])=> okStore.key(w)));
        const data = okStore._();
        let touched=false; for(const k of Object.keys(data)){ if(!keep.has(k)){ delete data[k]; touched=true; } }
        if (touched) okStore.save(data);
      }catch(_){ }
    }

    /* ====== Vocabulary render & events ====== */
    const vocabEl = $('#vocab');
    function rowHTML(w,t){
      return `<div class="vrow" data-word="${w}">
        <div class="cell word">${w}</div>
        <button class="cell icon-btn speak" aria-label="Произнести ${w}">${SPEAKER_SVG}</button>
        <div class="cell trans">${t}</div>
        <div class="cell okcount">${okStore.get(w)}</div>
        <button class="cell icon-btn delete" aria-label="Удалить ${w}">×</button>
      </div>`;
    }
    function renderVocab(list){ vocabEl.innerHTML = list.map(([w,t])=>rowHTML(w,t)).join(''); }
    function updateVocabView(){
      // Place last imported words first (in input order), then the rest sorted as before
      const byWord = new Map(WORDS.map(([w,t])=>[w,t]));
      const rest = WORDS.filter(([w])=> !LAST_IMPORTED.includes(w));
      const sortedRest = rest.slice().sort((a,b)=>{ const oa=okStore.get(a[0]), ob=okStore.get(b[0]); return oa!==ob? oa-ob : a[0].localeCompare(b[0]); });
      const first = LAST_IMPORTED.map(w=> [w, byWord.get(w)]).filter(([,t])=>typeof t!=="undefined");
      const finalList = first.concat(sortedRest);
      renderVocab(finalList);
      // highlight newly imported
      LAST_IMPORTED.forEach(w=>{
        const row = document.querySelector(`.vrow[data-word="${w.replace(/"/g,'\"')}"]`);
        if (row) row.classList.add('new');
      });
    }

    // Add new blank row for input and commit on Enter/blur
    const fabAdd = $('#fabAdd');
    function insertEditableRow(){
      const row = document.createElement('div'); row.className='vrow'; row.innerHTML = `
        <div class="cell word" contenteditable="true" data-edit="word"></div>
        <button class="cell icon-btn speak" aria-label="Произнести">${SPEAKER_SVG}</button>
        <div class="cell trans" contenteditable="true" data-edit="trans"></div>
        <div class="cell okcount">0</div>
        <button class="cell icon-btn delete" aria-label="Удалить">×</button>`;
      vocabEl.prepend(row);
      const wCell = row.querySelector('[data-edit=word]');
      const tCell = row.querySelector('[data-edit=trans]');
      const commit = ()=>{
        const w=(wCell.textContent||'').trim();
        const t=(tCell.textContent||'').trim();
        if (w && t){ if (!WORDS.find(([x])=>x===w)) WORDS.unshift([w,t]); saveVocab(); updateVocabView(); }
      };
      wCell.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); tCell.focus(); } });
      tCell.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); commit(); } });
      wCell.addEventListener('blur', commit); tCell.addEventListener('blur', commit);
      wCell.focus();
    }
    fabAdd.addEventListener('click', insertEditableRow);

    // Commit any draft editable rows on unload (to persist accidental refresh)
    function commitDraftRows(){
      const drafts = Array.from(vocabEl.querySelectorAll('.vrow'));
      for (const row of drafts){
        const wCell = row.querySelector('[data-edit=word]');
        const tCell = row.querySelector('[data-edit=trans]');
        if (!wCell || !tCell) continue;
        const w=(wCell.textContent||'').trim();
        const t=(tCell.textContent||'').trim();
        if (w && t && !WORDS.find(([x])=>x===w)) { WORDS.unshift([w,t]); }
      }
      if (drafts.length) { saveVocab(); }
    }
    window.addEventListener('beforeunload', commitDraftRows);

    // Inline edit for existing rows (click on word/translation)
    function startInlineEdit(cell, type){
      if (!cell || cell.isContentEditable) return;
      const row = cell.closest('.vrow');
      const oldWord = row?.dataset.word || row.querySelector('.cell.word')?.textContent?.trim() || '';
      const oldText = cell.textContent;
      cell.setAttribute('contenteditable','true');
      focusEnd(cell);
      const cleanup = ()=>{ cell.removeAttribute('contenteditable'); cell.removeEventListener('blur', onBlur); cell.removeEventListener('keydown', onKey); };
      const commit = ()=>{
        const txt = (cell.textContent||'').trim();
        if (!txt){ cell.textContent = oldText; cleanup(); return; }
        const idx = WORDS.findIndex(([w])=>w===oldWord);
        if (idx>-1){
          if (type==='word'){
            const newWord = txt;
            if (newWord !== oldWord){
              WORDS[idx][0] = newWord;
              const cnt = okStore.get(oldWord);
              if (cnt){ okStore.del(oldWord); okStore.inc(newWord, cnt); }
            }
          } else {
            WORDS[idx][1] = txt;
          }
        }
        saveVocab();
        updateVocabView();
        cleanup();
      };
      const cancel = ()=>{ cell.textContent = oldText; cleanup(); };
      const onBlur = ()=> commit();
      const onKey = (e)=>{ if (e.key==='Enter'){ e.preventDefault(); commit(); } else if (e.key==='Escape'){ e.preventDefault(); cancel(); } };
      cell.addEventListener('blur', onBlur);
      cell.addEventListener('keydown', onKey);
    }

    // Delegated events: delete/speak/edit
    vocabEl.addEventListener('click', (e)=>{
      const row = e.target.closest('.vrow'); if(!row) return;
      if (e.target.closest('.icon-btn.delete')){
        const word = row.dataset.word || row.querySelector('.cell.word')?.textContent?.trim()||'';
        okStore.del(word);
        const idx = WORDS.findIndex(([w])=>w===word); if (idx>-1) WORDS.splice(idx,1);
        saveVocab();
        updateVocabView();
        return;
      }
      if (e.target.closest('.icon-btn.speak')){
        const word = row.dataset.word || row.querySelector('.cell.word')?.textContent?.trim()||'';
        speakWord(word);
        return;
      }
      const wCell = e.target.closest('.cell.word'); if (wCell){ startInlineEdit(wCell, 'word'); return; }
      const tCell = e.target.closest('.cell.trans'); if (tCell){ startInlineEdit(tCell, 'trans'); return; }
    });

    window.addEventListener('storage', (e)=>{
      if (e.key===VOCAB_KEY) { loadVocab(); updateVocabView(); }
      if (e.key===OK_KEY)     { updateVocabView(); }
      if (e.key==='vocabTotals') { loadTotals(); renderScore(); }
    });

    /* ====== Game state ====== */
    const runnerEl = $('.runner');
    const obstacleEl = $('.obstacle');
    obstacleEl.classList.add('transparent');
    const clearFirst = ()=>{ obstacleEl.classList.remove('transparent'); obstacleEl.removeEventListener('animationiteration', clearFirst); };
    obstacleEl.addEventListener('animationiteration', clearFirst);
    setTimeout(()=>{ if (obstacleEl.classList.contains('transparent')) clearFirst(); }, 3500);
    const overlay = $('#quizOverlay');
    const quizWordEl = $('#quizWord');
    const quizInputCE = $('#quizInputCE');

    const okEl=$('#ok'), failEl=$('#fail');
    let ok=0, fail=0; const renderScore=()=>{ okEl.textContent=ok; failEl.textContent=fail; };
    const TOTALS_KEY='vocabTotals';
    const loadTotals=()=>{ try{ const t=JSON.parse(localStorage.getItem(TOTALS_KEY)||'{}'); ok=t.ok|0; fail=t.fail|0; }catch(_){}};
    const saveTotals=()=>{ localStorage.setItem(TOTALS_KEY, JSON.stringify({ok, fail})); };
    function pickWord(){
      // 1) If there is a queued mistaken word whose delay reached 0 — show it first
      const readyIdx = RETRY_QUEUE.findIndex(it => (it && (it.delay|0) <= 0));
      if (readyIdx > -1) {
        const it = RETRY_QUEUE.splice(readyIdx, 1)[0];
        return { w: it.w, t: it.t };
      }
      // 2) Otherwise use weighted random by mastery (okStore)
      const list = WORDS.filter(([w,t])=>w&&t);
      if(!list.length) return {w:'word', t:'слово'};
      const weights = list.map(([w])=> 1 / (okStore.get(w) + 1));
      const tot = weights.reduce((a,b)=>a+b,0) || 1; let r = Math.random()*tot;
      for (let i=0;i<list.length;i++){ r-=weights[i]; if (r<=0) return { w:list[i][0], t:list[i][1] }; }
      const last=list[list.length-1]; return { w:last[0], t:last[1] };
    }

    let askedThisRun=false, currentQA=null;
    let cooldownUntil = 0;
    let revealTimer=null; let revealMode=null;

    function playWrongSequence(){
      const svg = document.querySelector('.runner-shape');
      if (svg) {
        svg.classList.remove('spinNeg90'); void svg.offsetWidth; svg.classList.add('spinNeg90');
        svg.addEventListener('animationend', ()=> svg.classList.remove('spinNeg90'), { once:true });
      }
      runnerEl.classList.add('knock');
      const onKnockEnd = (e)=>{ if (e.animationName==='knockback'){ runnerEl.classList.remove('knock'); runnerEl.removeEventListener('animationend', onKnockEnd); } };
      runnerEl.addEventListener('animationend', onKnockEnd);
      obstacleEl.style.opacity = '0';
      obstacleEl.style.animation = 'none';
      void obstacleEl.offsetWidth;
      obstacleEl.style.animation = '';
      requestAnimationFrame(()=>{ obstacleEl.style.opacity = '1'; });
      askedThisRun = false;
    }

    function showQuiz(){
      askedThisRun=true;
      // Decrease delay counters for all scheduled retries (one step per asked card)
      RETRY_QUEUE.forEach(it=>{ if (it.delay>0) it.delay--; });
      currentQA = pickWord();
      quizWordEl.textContent = currentQA.w;
      obstacleEl.style.animationPlayState = 'paused';
      runnerEl.style.animationPlayState   = 'paused';
      document.body.classList.add('paused');
      overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
      requestAnimationFrame(()=>focusEnd(quizInputCE));
    }
    function hideQuiz(){
      overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true');
      quizInputCE.textContent='';
      document.body.classList.remove('paused');
      obstacleEl.style.animationPlayState = '';
      runnerEl.style.animationPlayState   = '';
    }

    quizInputCE.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        if (quizInputCE.classList.contains('showing-correct')) {
          if (revealTimer) { clearTimeout(revealTimer); revealTimer = null; }
          quizInputCE.classList.remove('showing-correct');
          hideQuiz();
          if (revealMode === 'wrong') { playWrongSequence(); }
          revealMode = null;
          askedThisRun = false;
          cooldownUntil = performance.now() + 400;
          return;
        }
        if(!currentQA){ hideQuiz(); return; }
        const val=(quizInputCE.textContent||'').trim();
        if (isFuzzyCorrect(val, currentQA.t)){
          ok++; okStore.inc(currentQA.w,1); renderScore(); saveTotals(); updateVocabView(); 
          if (document.body.classList.contains('inverted')) document.body.classList.remove('inverted');
          const exactFull = normCmp(val) === normCmp(currentQA.t);
          if (exactFull) {
            hideQuiz();
            askedThisRun = false;
            cooldownUntil = performance.now() + 400;
          } else {
            quizInputCE.textContent = currentQA.t;
            quizInputCE.classList.add('showing-correct');
            revealMode = 'ok';
            revealTimer = setTimeout(()=>{
              quizInputCE.classList.remove('showing-correct');
              hideQuiz();
              revealMode = null; revealTimer = null;
              askedThisRun = false; cooldownUntil = performance.now() + 400;
            }, 2900);
          }
        } else {
          fail++; renderScore(); saveTotals(); document.body.classList.add('inverted');
          // Schedule this word to reappear after 1..3 other cards
          if (currentQA && currentQA.w) {
            const existing = RETRY_QUEUE.find(it => it.w === currentQA.w);
            const d = Math.floor(Math.random()*3) + 1; // 1..3
            if (existing) { existing.delay = Math.min(existing.delay, d); }
            else { RETRY_QUEUE.push({ w: currentQA.w, t: currentQA.t, delay: d }); }
          }
          quizInputCE.textContent = currentQA.t;
          quizInputCE.classList.add('showing-correct');
          revealMode = 'wrong';
          revealTimer = setTimeout(()=>{
            quizInputCE.classList.remove('showing-correct');
            hideQuiz();
            playWrongSequence();
            revealTimer = null;
          }, 2900);
        }
      }
    });

    function loop(){
      const r1 = runnerEl.getBoundingClientRect();
      const r2 = obstacleEl.getBoundingClientRect();
      const gap = r2.left - r1.right;
      const approaching = r2.left >= r1.right - 1;
      const shouldPrompt = approaching && gap <= 20 && gap >= 0;
      const nearMiss = r1.right > r2.left && r1.left < r2.left + 5;
      const cooled = performance.now() >= cooldownUntil;
      if (!askedThisRun && cooled && (shouldPrompt || nearMiss)) showQuiz();
      const passedLeft = r2.right < r1.left - 5;
      const farRight = r2.left > r1.right + innerWidth*0.6;
      const offLeft = r2.right < -20;
      if ((askedThisRun && passedLeft && !overlay.classList.contains('show')) || farRight || offLeft) askedThisRun=false;
      requestAnimationFrame(loop);
    }
    // Init — normal boot: keep user's history in localStorage
    loadTotals();
    loadVocab();
    purgeOrphanOk();
    renderScore();
    updateVocabView();

    
    const dlg = document.querySelector('.dialog');
    dlg && dlg.addEventListener('click', ()=>focusEnd(quizInputCE));

    loop(); setPage('game');

    /* ===== List dialog wiring ===== */
    const fabList = document.getElementById('fabList');
    const listOverlay = document.getElementById('listOverlay');
    const listText = document.getElementById('listText');
    const listOk = document.getElementById('listOk');
    const listClose = document.getElementById('listClose');

    function showListDialog(){
      listOverlay.classList.add('show');
      listOverlay.setAttribute('aria-hidden','false');
      listText.value='';
      listText.focus();
    }
    function hideListDialog(){
      listOverlay.classList.remove('show');
      listOverlay.setAttribute('aria-hidden','true');
    }
    function importFromRaw(text){
      const lines = String(text || '').split(/\r?\n+/).map(s => s.trim()).filter(Boolean);
      let added = 0; const newOnes = [];
      for (let line of lines){
        // Нормализуем редкие виды тире к обычному эм-тире
        line = line.replace(/[\u2012\u2013\u2014\u2015]/g, '—');
        // Поддерживаем: —, –, -, :, ;, |, таб, а также -> и =>
        let m = line.match(/^(.*?)\s*(?:—|–|-|:|;|\||->|=>|\t)\s*(.+)$/);
        if (!m) m = line.match(/^(.*?)\s{2,}(.+)$/); // фолбэк: 2+ пробелов
        if (!m) continue;
        const w = m[1].trim();
        const t = m[2].trim();
        if (!w || !t) continue;
        if (!WORDS.find(([x]) => x === w)) { WORDS.unshift([w, t]); newOnes.push(w); added++; }
      }
      LAST_IMPORTED = newOnes;
      if (added){ saveVocab(); updateVocabView(); setPage('vocab'); }
      return added;
    }
    fabList && fabList.addEventListener('click', showListDialog);
    listClose && listClose.addEventListener('click', hideListDialog);
    listOk && listOk.addEventListener('click', ()=>{ importFromRaw(listText.value); hideListDialog(); });
    window.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && listOverlay.classList.contains('show')) hideListDialog(); });
    listOverlay && listOverlay.addEventListener('click', (e)=>{ if (e.target===listOverlay) hideListDialog(); });
  })();
  </script>
</body>
</html>
